// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSCulling

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

//////	对每棵草的位置进行和不同mipmap等级的深度贴图里的深度做比对，
////    把没有被剔除的草的位置写入posVisibleBuffer 里，

//     需要从c#那边把，
////   带mipmap的深度纹理，
  ///   所以草地 位置，
////   相机的位置和前方向，
////   相机的 fov/2（计算mipmap用）
///     这几个参数传过来，以进行遮挡裁剪计算。

StructuredBuffer<float3> posAllBuffer;
RWStructuredBuffer<float3> posVisibleBuffer;
RWStructuredBuffer<int> bufferWithArgs;
float3 cmrPos;
float3 cmrDir;
float cmrHalfFov;
float4x4 matrix_VP;
Texture2D HZB_Depth;
float useHzb;


[numthreads(16,16,1)]
void CSCulling(uint3 id : SV_DispatchThreadID)
{
	uint index = id.y * 400+ id.x;
	float3 itemPos = posAllBuffer[index];
	//float3 itemDir = normalize(itemPos - cmrPos);
	//float rot = dot(cmrDir, itemDir);

 
 		float4 clipPos = mul(matrix_VP, float4(itemPos-cmrDir *0.2, 1));
 
	       ///用其次裁剪坐标做一个视野范围内的判定，
		if (max(abs(clipPos.x), abs(clipPos.y)) > clipPos.w+0.7)
				return;
	
 		if (useHzb > 0.5) {
			
			clipPos.xyz /= clipPos.w;
			clipPos.xy = clipPos.xy * 0.5 + 0.5;

		/*	 float4 clip_left_Pos = mul(matrix_VP, float4(itemPos - half3(0.5, 0.5, 0.5),1));
			clip_left_Pos.xyz /= clip_left_Pos.w;
			clip_left_Pos.xy = clip_left_Pos.xy * 0.5 + 0.5;

			float scWid =max(abs(clipPos.x - clip_left_Pos.x), abs(clipPos.y - clip_left_Pos.y)) * 1024;
			  clip_left_Pos = mul(matrix_VP, float4(itemPos + half3(0.5, 0.5, 0.5), 1));
			clip_left_Pos.xyz /= clip_left_Pos.w;
			clip_left_Pos.xy = clip_left_Pos.xy * 0.5 + 0.5;

			  scWid =max(scWid, max(abs(clipPos.x - clip_left_Pos.x), abs(clipPos.y - clip_left_Pos.y)) * 1024); */
		
		 ////根据草的其次裁剪坐标的w值，计算mipmap等级
		 	float scWid = 0.2 / (tan(cmrHalfFov * 3.1415926 / 180)* clipPos.w) * 1024;

			uint mips = ( uint)clamp(log2(scWid),0,7);
		
		///根据mapmap等级，和其次裁剪坐标的xy,位置，计算uv，
			//if (scWid < 20&&index%max(2,((uint)scWid/1.5))==0)return;
			uint texScale = 1 << mips;
			uint2 uv = uint2( clipPos.xy * (1024 / texScale));
		 ///根据计算出的uv，和mipmap从深度纹理里，进行采样，采样四个，取四个里最小的
			float minD =min( min(HZB_Depth.mips[mips][uv.xy + uint2(0, 0)].r, HZB_Depth.mips[mips][uv.xy + uint2(0, 1)].r), min(HZB_Depth.mips[mips][uv.xy + uint2(1, 0)].r, HZB_Depth.mips[mips][uv.xy + uint2(1, 1)].r));
		     //当前草的深度比深度纹理里，采样出的，还要小，那么就剔除。
			if (minD > clipPos.z)
			 return;
		}
	 
 
	int currentIndex;
	InterlockedAdd(bufferWithArgs[1], 1, currentIndex);
	posVisibleBuffer[currentIndex] = itemPos;
	
   

}
